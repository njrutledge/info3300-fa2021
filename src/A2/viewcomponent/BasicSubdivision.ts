import {Vec2, VertexArray2D} from "../../anigraph";

/**
 *  This function is designed to subdivide a shape. It takes in the shape's
 *  current array of vertices along its boundary, subdivides its shape, and returns
 *  a new array of vertices that build its subdivided boundary.
 *
 *  For a shape whose boundary is defined by a sequence of connected vertices,
 *  the subdivision of this shape is generated by increasing the granularity of
 *  this boundary. Specifically, we subdivide the boundary by generating a new set of
 *  connected vertices.
 *  This new set of vertices includes:
 *      1. midpoints of each old edge
 *      2. midpoints of adjacent old edges' midpoints
 *
 *  eg. a triangle A formulated by three points p1, p2 , p3
 *  If we subdivide this triangle A, we would consider {p1, p2, p3} as its set of old vertices.
 *  The new set of vertices would include:
 *      1. midpoints of each old edge:
 *          (p1 + p2)/2, (p2 + p3)/2, (p3 + p1)/2
 *      2. midpoints of old adjacent edges' midpoints:
 *          ((p1 + p2)/2 + (p2 + p3)/2)/2,  ((p2 + p3)/2 + (p3 + p1)/2)/2, ((p3 + p1)/2 + (p1 + p3)/2)/2
 *
 * @param oldVerts An array of connected vertices that formulates the current boundary of a shape
 * @return newVerts An array of new connected vertices that formulates the subdivided boundary of a shape
 */
export function getSubdividedVerts(oldVerts:VertexArray2D){

    /***
     * The example below simply doubles every vertex in the array as a demonstration of how to access the vertices of
     * the old array and add vertices to the new one.
     */

    // first let's create a new vertex array:
    let newVerts = new VertexArray2D();

    for(let v=0;v<oldVerts.length;v++){
        //we can use newVerts.addVertex to add to it:
        newVerts.addVertex(oldVerts.getPoint2DAt(v));
        newVerts.addVertex(oldVerts.getPoint2DAt(v));
    }

    return newVerts;
}
